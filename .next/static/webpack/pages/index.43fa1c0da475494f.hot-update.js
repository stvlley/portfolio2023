"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/waves.js":
/*!**********************!*\
  !*** ./src/waves.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"waves\": function() { return /* binding */ waves; }\n/* harmony export */ });\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar waves = function() {\n    var ShaderProgram = /*#__PURE__*/ function() {\n        \"use strict\";\n        function ShaderProgram(holder) {\n            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            var _this = this;\n            _classCallCheck(this, ShaderProgram);\n            options = Object.assign({\n                antialias: false,\n                depthTest: false,\n                mousemove: false,\n                autosize: true,\n                side: \"front\",\n                vertex: \"\\n                   precision highp float;\\n           \\n                   attribute vec4 a_position;\\n                   attribute vec4 a_color;\\n           \\n                   uniform float u_time;\\n                   uniform vec2 u_resolution;\\n                   uniform vec2 u_mousemove;\\n                   uniform mat4 u_projection;\\n           \\n                   varying vec4 v_color;\\n           \\n                   void main() {\\n           \\n                     gl_Position = u_projection * a_position;\\n                     gl_PointSize = (10.0 / gl_Position.w) * 100.0;\\n           \\n                     v_color = a_color;\\n           \\n                   }\",\n                fragment: \"\\n                   precision highp float;\\n           \\n                   uniform sampler2D u_texture;\\n                   uniform int u_hasTexture;\\n           \\n                   varying vec4 v_color;\\n           \\n                   void main() {\\n           \\n                     if ( u_hasTexture == 1 ) {\\n           \\n                       gl_FragColor = v_color * texture2D(u_texture, gl_PointCoord);\\n           \\n                     } else {\\n           \\n                       gl_FragColor = v_color;\\n           \\n                     }\\n           \\n                   }\",\n                uniforms: {},\n                buffers: {},\n                camera: {},\n                texture: null,\n                onUpdate: function() {},\n                onResize: function() {}\n            }, options);\n            var uniforms = Object.assign({\n                time: {\n                    type: \"float\",\n                    value: 0\n                },\n                hasTexture: {\n                    type: \"int\",\n                    value: 0\n                },\n                resolution: {\n                    type: \"vec2\",\n                    value: [\n                        0,\n                        0\n                    ]\n                },\n                mousemove: {\n                    type: \"vec2\",\n                    value: [\n                        0,\n                        0\n                    ]\n                },\n                projection: {\n                    type: \"mat4\",\n                    value: [\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ]\n                }\n            }, options.uniforms);\n            var buffers = Object.assign({\n                position: {\n                    size: 3,\n                    data: []\n                },\n                color: {\n                    size: 4,\n                    data: []\n                }\n            }, options.buffers);\n            var camera = Object.assign({\n                fov: 60,\n                near: 1,\n                far: 10000,\n                aspect: 1,\n                z: 100,\n                perspective: true\n            }, options.camera);\n            var canvas = document.createElement(\"canvas\");\n            var gl = canvas.getContext(\"webgl\", {\n                antialias: options.antialias\n            });\n            if (!gl) return false;\n            this.count = 0;\n            this.gl = gl;\n            this.canvas = canvas;\n            this.camera = camera;\n            this.holder = holder;\n            this.onUpdate = options.onUpdate;\n            this.onResize = options.onResize;\n            this.data = {};\n            holder.appendChild(canvas);\n            this.createProgram(options.vertex, options.fragment);\n            this.createBuffers(buffers);\n            this.createUniforms(uniforms);\n            this.updateBuffers();\n            this.updateUniforms();\n            this.createTexture(options.texture);\n            gl.enable(gl.BLEND);\n            gl.enable(gl.CULL_FACE);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n            gl[options.depthTest ? \"enable\" : \"disable\"](gl.DEPTH_TEST);\n            if (options.autosize) window.addEventListener(\"resize\", function(e) {\n                return _this.resize(e);\n            }, false);\n            if (options.mousemove) window.addEventListener(\"mousemove\", function(e) {\n                return _this.mousemove(e);\n            }, false);\n            this.resize();\n            this.update = this.update.bind(this);\n            this.time = {\n                start: performance.now(),\n                old: performance.now()\n            };\n            this.update();\n        }\n        _createClass(ShaderProgram, [\n            {\n                key: \"mousemove\",\n                value: function mousemove(e) {\n                    var x = e.pageX / this.width * 2 - 1;\n                    var y = e.pageY / this.height * 2 - 1;\n                    this.uniforms.mousemove = [\n                        x,\n                        y\n                    ];\n                }\n            },\n            {\n                key: \"resize\",\n                value: function resize(e) {\n                    var holder = this.holder;\n                    var canvas = this.canvas;\n                    var gl = this.gl;\n                    var width = this.width = holder.offsetWidth;\n                    var height = this.height = holder.offsetHeight;\n                    var aspect = this.aspect = width / height;\n                    var dpi = devicePixelRatio;\n                    canvas.width = width * dpi;\n                    canvas.height = height * dpi;\n                    canvas.style.width = width + \"px\";\n                    canvas.style.height = height + \"px\";\n                    gl.viewport(0, 0, width * dpi, height * dpi);\n                    gl.clearColor(0, 0, 0, 0);\n                    this.uniforms.resolution = [\n                        width,\n                        height\n                    ];\n                    this.uniforms.projection = this.setProjection(aspect);\n                    this.onResize(width, height, dpi);\n                }\n            },\n            {\n                key: \"setProjection\",\n                value: function setProjection(aspect) {\n                    var camera = this.camera;\n                    if (camera.perspective) {\n                        camera.aspect = aspect;\n                        var fovRad = camera.fov * (Math.PI / 180);\n                        var f = Math.tan(Math.PI * 0.5 - 0.5 * fovRad);\n                        var rangeInv = 1.0 / (camera.near - camera.far);\n                        var matrix = [\n                            f / camera.aspect,\n                            0,\n                            0,\n                            0,\n                            0,\n                            f,\n                            0,\n                            0,\n                            0,\n                            0,\n                            (camera.near + camera.far) * rangeInv,\n                            -1,\n                            0,\n                            0,\n                            camera.near * camera.far * rangeInv * 2,\n                            0, \n                        ];\n                        matrix[14] += camera.z;\n                        matrix[15] += camera.z;\n                        return matrix;\n                    } else {\n                        return [\n                            2 / this.width,\n                            0,\n                            0,\n                            0,\n                            0,\n                            -2 / this.height,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            -1,\n                            1,\n                            0,\n                            1, \n                        ];\n                    }\n                }\n            },\n            {\n                key: \"createShader\",\n                value: function createShader(type, source) {\n                    var gl = this.gl;\n                    var shader = gl.createShader(type);\n                    gl.shaderSource(shader, source);\n                    gl.compileShader(shader);\n                    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                        return shader;\n                    } else {\n                        console.log(gl.getShaderInfoLog(shader));\n                        gl.deleteShader(shader);\n                    }\n                }\n            },\n            {\n                key: \"createProgram\",\n                value: function createProgram(vertex, fragment) {\n                    var gl = this.gl;\n                    var vertexShader = this.createShader(gl.VERTEX_SHADER, vertex);\n                    var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragment);\n                    var program = gl.createProgram();\n                    gl.attachShader(program, vertexShader);\n                    gl.attachShader(program, fragmentShader);\n                    gl.linkProgram(program);\n                    if (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                        gl.useProgram(program);\n                        this.program = program;\n                    } else {\n                        console.log(gl.getProgramInfoLog(program));\n                        gl.deleteProgram(program);\n                    }\n                }\n            },\n            {\n                key: \"createUniforms\",\n                value: function createUniforms(data) {\n                    var _this = this;\n                    var gl = this.gl;\n                    var uniforms = this.data.uniforms = data;\n                    var values = this.uniforms = {};\n                    Object.keys(uniforms).forEach(function(name) {\n                        var _this1 = _this;\n                        var uniform = uniforms[name];\n                        uniform.location = gl.getUniformLocation(_this.program, \"u_\" + name);\n                        Object.defineProperty(values, name, {\n                            set: function(value) {\n                                uniforms[name].value = value;\n                                _this1.setUniform(name, value);\n                            },\n                            get: function() {\n                                return uniforms[name].value;\n                            }\n                        });\n                    });\n                }\n            },\n            {\n                key: \"setUniform\",\n                value: function setUniform(name, value) {\n                    var gl = this.gl;\n                    var uniform = this.data.uniforms[name];\n                    uniform.value = value;\n                    switch(uniform.type){\n                        case \"int\":\n                            {\n                                gl.uniform1i(uniform.location, value);\n                                break;\n                            }\n                        case \"float\":\n                            {\n                                gl.uniform1f(uniform.location, value);\n                                break;\n                            }\n                        case \"vec2\":\n                            {\n                                var _gl;\n                                (_gl = gl).uniform2f.apply(_gl, [\n                                    uniform.location\n                                ].concat(_toConsumableArray(value)));\n                                break;\n                            }\n                        case \"vec3\":\n                            {\n                                var _gl1;\n                                (_gl1 = gl).uniform3f.apply(_gl1, [\n                                    uniform.location\n                                ].concat(_toConsumableArray(value)));\n                                break;\n                            }\n                        case \"vec4\":\n                            {\n                                var _gl2;\n                                (_gl2 = gl).uniform4f.apply(_gl2, [\n                                    uniform.location\n                                ].concat(_toConsumableArray(value)));\n                                break;\n                            }\n                        case \"mat2\":\n                            {\n                                gl.uniformMatrix2fv(uniform.location, false, value);\n                                break;\n                            }\n                        case \"mat3\":\n                            {\n                                gl.uniformMatrix3fv(uniform.location, false, value);\n                                break;\n                            }\n                        case \"mat4\":\n                            {\n                                gl.uniformMatrix4fv(uniform.location, false, value);\n                                break;\n                            }\n                    }\n                // ivec2       : uniform2i,\n                // ivec3       : uniform3i,\n                // ivec4       : uniform4i,\n                // sampler2D   : uniform1i,\n                // samplerCube : uniform1i,\n                // bool        : uniform1i,\n                // bvec2       : uniform2i,\n                // bvec3       : uniform3i,\n                // bvec4       : uniform4i,\n                }\n            },\n            {\n                key: \"updateUniforms\",\n                value: function updateUniforms() {\n                    var _this = this;\n                    var gl = this.gl;\n                    var uniforms = this.data.uniforms;\n                    Object.keys(uniforms).forEach(function(name) {\n                        var uniform = uniforms[name];\n                        _this.uniforms[name] = uniform.value;\n                    });\n                }\n            },\n            {\n                key: \"createBuffers\",\n                value: function createBuffers(data1) {\n                    var _this = this;\n                    var gl = this.gl;\n                    var buffers = this.data.buffers = data1;\n                    var values = this.buffers = {};\n                    Object.keys(buffers).forEach(function(name) {\n                        var _this2 = _this;\n                        var buffer = buffers[name];\n                        buffer.buffer = _this.createBuffer(\"a_\" + name, buffer.size);\n                        Object.defineProperty(values, name, {\n                            set: function(data) {\n                                buffers[name].data = data;\n                                _this2.setBuffer(name, data);\n                                if (name == \"position\") _this2.count = buffers.position.data.length / 3;\n                            },\n                            get: function() {\n                                return buffers[name].data;\n                            }\n                        });\n                    });\n                }\n            },\n            {\n                key: \"createBuffer\",\n                value: function createBuffer(name, size) {\n                    var gl = this.gl;\n                    var program = this.program;\n                    var index = gl.getAttribLocation(program, name);\n                    var buffer = gl.createBuffer();\n                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n                    gl.enableVertexAttribArray(index);\n                    gl.vertexAttribPointer(index, size, gl.FLOAT, false, 0, 0);\n                    return buffer;\n                }\n            },\n            {\n                key: \"setBuffer\",\n                value: function setBuffer(name, data) {\n                    var gl = this.gl;\n                    var buffers = this.data.buffers;\n                    if (name == null && !gl.bindBuffer(gl.ARRAY_BUFFER, null)) return;\n                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers[name].buffer);\n                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\n                }\n            },\n            {\n                key: \"updateBuffers\",\n                value: function updateBuffers() {\n                    var gl = this.gl;\n                    var buffers = this.buffers;\n                    Object.keys(buffers).forEach(function(name) {\n                        return buffers[name] = buffer.data;\n                    });\n                    this.setBuffer(null);\n                }\n            },\n            {\n                key: \"createTexture\",\n                value: function createTexture(src) {\n                    var gl = this.gl;\n                    var texture = gl.createTexture();\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([\n                        0,\n                        0,\n                        0,\n                        0\n                    ]));\n                    this.texture = texture;\n                    if (src) {\n                        this.uniforms.hasTexture = 1;\n                        this.loadTexture(src);\n                    }\n                }\n            },\n            {\n                key: \"loadTexture\",\n                value: function loadTexture(src) {\n                    var gl = this.gl;\n                    var texture = this.texture;\n                    var textureImage = new Image();\n                    textureImage.onload = function() {\n                        gl.bindTexture(gl.TEXTURE_2D, texture);\n                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    };\n                    textureImage.src = src;\n                }\n            },\n            {\n                key: \"update\",\n                value: function update() {\n                    var gl = this.gl;\n                    var now = performance.now();\n                    var elapsed = (now - this.time.start) / 5000;\n                    var delta = now - this.time.old;\n                    this.time.old = now;\n                    this.uniforms.time = elapsed;\n                    if (this.count > 0) {\n                        // gl.clear(gl.COLORBUFFERBIT);\n                        gl.drawArrays(gl.POINTS, 0, this.count);\n                    }\n                    this.onUpdate(delta);\n                    requestAnimationFrame(this.update);\n                }\n            }\n        ]);\n        return ShaderProgram;\n    }();\n    var pointSize = 2.5;\n    var waves = new ShaderProgram(document.querySelector(\".waves\"), {\n        texture: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAb1BMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8v0wLRAAAAJHRSTlMAC/goGvDhmwcExrVjWzrm29TRqqSKenRXVklANSIUE8mRkGpv+HOfAAABCElEQVQ4y4VT13LDMAwLrUHteO+R9f/fWMfO6dLaPeKVEECRxOULWsEGpS9nULDwia2Y+ALqUNbAWeg775zv+sA4/FFRMxt8U2FZFCVWjR/YrH4/H9sarclSKdPMWKzb8VsEeHB3m0shkhVCyNzeXeAQ9Xl4opEieX2QCGnwGbj6GMyjw9t1K0fK9YZunPXeAGsfJtYjwzxaBnozGGorYz0ypK2HzQSYx1y8DgSRo2ewOiyh2QWOEk1Y9OrQV0a8TiBM1a8eMHWYnRMy7CZ4t1CmyRkhSUvP3gRXyHOCLBxNoC3IJv//ZrJ/kxxUHPUB+6jJZZHrpg6GOjnqaOmzp4NDR48OLxn/H27SRQ08S0ZJAAAAAElFTkSuQmCC\",\n        uniforms: {\n            size: {\n                type: \"float\",\n                value: pointSize\n            },\n            field: {\n                type: \"vec3\",\n                value: [\n                    0,\n                    0,\n                    0\n                ]\n            },\n            speed: {\n                type: \"float\",\n                value: 5\n            }\n        },\n        vertex: \"\\n               #define M_PI 3.1415926535897932384626433832795\\n           \\n               precision highp float;\\n           \\n               attribute vec4 a_position;\\n               attribute vec4 a_color;\\n           \\n               uniform float u_time;\\n               uniform float u_size;\\n               uniform float u_speed;\\n               uniform vec3 u_field;\\n               uniform mat4 u_projection;\\n           \\n               varying vec4 v_color;\\n           \\n               void main() {\\n           \\n                 vec3 pos = a_position.xyz;\\n           \\n                 pos.y += (\\n                   cos(pos.x / u_field.x * M_PI * 8.0 + u_time * u_speed) +\\n                   sin(pos.z / u_field.z * M_PI * 8.0 + u_time * u_speed)\\n                 ) * u_field.y;\\n           \\n                 gl_Position = u_projection * vec4( pos.xyz, a_position.w );\\n                 gl_PointSize = ( u_size / gl_Position.w ) * 100.0;\\n           \\n                 v_color = a_color;\\n           \\n               }\",\n        fragment: \"\\n               precision highp float;\\n           \\n               uniform sampler2D u_texture;\\n           \\n               varying vec4 v_color;\\n           \\n               void main() {\\n           \\n                 gl_FragColor = v_color * texture2D(u_texture, gl_PointCoord);\\n           \\n               }\",\n        onResize: function onResize(w, h, dpi) {\n            var position = [], color = [];\n            var width = 400 * (w / h);\n            var depth = 400;\n            var height = 3;\n            var distance = 5;\n            for(var x = 0; x < width; x += distance){\n                for(var z = 0; z < depth; z += distance){\n                    position.push(-width / 2 + x, -30, -depth / 2 + z);\n                    color.push(0, 1 - x / width * 1, 0.5 + x / width * 0.5, z / depth);\n                }\n            }\n            this.uniforms.field = [\n                width,\n                height,\n                depth\n            ];\n            this.buffers.position = position;\n            this.buffers.color = color;\n            this.uniforms.size = h / 400 * pointSize * dpi;\n        }\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2lKLElBQUksQ0FDUixDQUFDLEVBQ0QsQ0FBQyxHQUFHLENBQUUsR0FBRzFHLEtBQUssR0FBSSxDQUFDLEVBQ25CLEdBQUcsR0FBRyxDQUFFLEdBQUdBLEtBQUssR0FBSSxHQUFHLEVBQ3ZCbEMsQ0FBQyxHQUFHMEksS0FBSyxDQUNWLENBQUM7aUJBQ0g7YUFDRjtZQUVELElBQUksQ0FBQzlKLFFBQVEsQ0FBQzBKLEtBQUssR0FBRztnQkFBQ3BHLEtBQUs7Z0JBQUVHLE1BQU07Z0JBQUVxRyxLQUFLO2FBQUMsQ0FBQztZQUU3QyxJQUFJLENBQUM3SixPQUFPLENBQUNXLFFBQVEsR0FBR0EsUUFBUSxDQUFDO1lBQ2pDLElBQUksQ0FBQ1gsT0FBTyxDQUFDYyxLQUFLLEdBQUdBLEtBQUssQ0FBQztZQUUzQixJQUFJLENBQUNmLFFBQVEsQ0FBQ2EsSUFBSSxHQUFHLENBQUUsR0FBRyxHQUFHLEdBQUkySSxTQUFTLEdBQUc1RixHQUFHLENBQUM7U0FDbEQ7S0FDRixDQUFDO0NBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvd2F2ZXMuanM/NzA3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3Qgd2F2ZXMgPSAoKSA9PiB7XHJcbiAgY2xhc3MgU2hhZGVyUHJvZ3JhbSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihob2xkZXIsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcclxuICAgICAgICB7XHJcbiAgICAgICAgICBhbnRpYWxpYXM6IGZhbHNlLFxyXG4gICAgICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcclxuICAgICAgICAgIG1vdXNlbW92ZTogZmFsc2UsXHJcbiAgICAgICAgICBhdXRvc2l6ZTogdHJ1ZSxcclxuICAgICAgICAgIHNpZGU6IFwiZnJvbnRcIixcclxuICAgICAgICAgIHZlcnRleDogYFxyXG4gICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgYXR0cmlidXRlIHZlYzQgYV9wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVfdGltZTtcclxuICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICB1bmlmb3JtIHZlYzIgdV9tb3VzZW1vdmU7XHJcbiAgICAgICAgICAgICAgICAgICB1bmlmb3JtIG1hdDQgdV9wcm9qZWN0aW9uO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHZfY29sb3I7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogYV9wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgZ2xfUG9pbnRTaXplID0gKDEwLjAgLyBnbF9Qb3NpdGlvbi53KSAqIDEwMC4wO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICB2X2NvbG9yID0gYV9jb2xvcjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIH1gLFxyXG4gICAgICAgICAgZnJhZ21lbnQ6IGBcclxuICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gaW50IHVfaGFzVGV4dHVyZTtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICBpZiAoIHVfaGFzVGV4dHVyZSA9PSAxICkge1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3IgKiB0ZXh0dXJlMkQodV90ZXh0dXJlLCBnbF9Qb2ludENvb3JkKTtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICB9YCxcclxuICAgICAgICAgIHVuaWZvcm1zOiB7fSxcclxuICAgICAgICAgIGJ1ZmZlcnM6IHt9LFxyXG4gICAgICAgICAgY2FtZXJhOiB7fSxcclxuICAgICAgICAgIHRleHR1cmU6IG51bGwsXHJcbiAgICAgICAgICBvblVwZGF0ZTogKCkgPT4ge30sXHJcbiAgICAgICAgICBvblJlc2l6ZTogKCkgPT4ge30sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvcHRpb25zXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCB1bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdGltZTogeyB0eXBlOiBcImZsb2F0XCIsIHZhbHVlOiAwIH0sXHJcbiAgICAgICAgICBoYXNUZXh0dXJlOiB7IHR5cGU6IFwiaW50XCIsIHZhbHVlOiAwIH0sXHJcbiAgICAgICAgICByZXNvbHV0aW9uOiB7IHR5cGU6IFwidmVjMlwiLCB2YWx1ZTogWzAsIDBdIH0sXHJcbiAgICAgICAgICBtb3VzZW1vdmU6IHsgdHlwZTogXCJ2ZWMyXCIsIHZhbHVlOiBbMCwgMF0gfSxcclxuICAgICAgICAgIHByb2plY3Rpb246IHtcclxuICAgICAgICAgICAgdHlwZTogXCJtYXQ0XCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3B0aW9ucy51bmlmb3Jtc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgYnVmZmVycyA9IE9iamVjdC5hc3NpZ24oXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcG9zaXRpb246IHsgc2l6ZTogMywgZGF0YTogW10gfSxcclxuICAgICAgICAgIGNvbG9yOiB7IHNpemU6IDQsIGRhdGE6IFtdIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvcHRpb25zLmJ1ZmZlcnNcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNhbWVyYSA9IE9iamVjdC5hc3NpZ24oXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgZm92OiA2MCxcclxuICAgICAgICAgIG5lYXI6IDEsXHJcbiAgICAgICAgICBmYXI6IDEwMDAwLFxyXG4gICAgICAgICAgYXNwZWN0OiAxLFxyXG4gICAgICAgICAgejogMTAwLFxyXG4gICAgICAgICAgcGVyc3BlY3RpdmU6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvcHRpb25zLmNhbWVyYVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHsgYW50aWFsaWFzOiBvcHRpb25zLmFudGlhbGlhcyB9KTtcclxuXHJcbiAgICAgIGlmICghZ2wpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xyXG4gICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgdGhpcy5ob2xkZXIgPSBob2xkZXI7XHJcbiAgICAgIHRoaXMub25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xyXG4gICAgICB0aGlzLm9uUmVzaXplID0gb3B0aW9ucy5vblJlc2l6ZTtcclxuICAgICAgdGhpcy5kYXRhID0ge307XHJcblxyXG4gICAgICBob2xkZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcclxuXHJcbiAgICAgIHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLnZlcnRleCwgb3B0aW9ucy5mcmFnbWVudCk7XHJcblxyXG4gICAgICB0aGlzLmNyZWF0ZUJ1ZmZlcnMoYnVmZmVycyk7XHJcbiAgICAgIHRoaXMuY3JlYXRlVW5pZm9ybXModW5pZm9ybXMpO1xyXG5cclxuICAgICAgdGhpcy51cGRhdGVCdWZmZXJzKCk7XHJcbiAgICAgIHRoaXMudXBkYXRlVW5pZm9ybXMoKTtcclxuXHJcbiAgICAgIHRoaXMuY3JlYXRlVGV4dHVyZShvcHRpb25zLnRleHR1cmUpO1xyXG5cclxuICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XHJcbiAgICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORSk7XHJcbiAgICAgIGdsW29wdGlvbnMuZGVwdGhUZXN0ID8gXCJlbmFibGVcIiA6IFwiZGlzYWJsZVwiXShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLmF1dG9zaXplKVxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIChlKSA9PiB0aGlzLnJlc2l6ZShlKSwgZmFsc2UpO1xyXG4gICAgICBpZiAob3B0aW9ucy5tb3VzZW1vdmUpXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgKGUpID0+IHRoaXMubW91c2Vtb3ZlKGUpLCBmYWxzZSk7XHJcblxyXG4gICAgICB0aGlzLnJlc2l6ZSgpO1xyXG5cclxuICAgICAgdGhpcy51cGRhdGUgPSB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpO1xyXG4gICAgICB0aGlzLnRpbWUgPSB7IHN0YXJ0OiBwZXJmb3JtYW5jZS5ub3coKSwgb2xkOiBwZXJmb3JtYW5jZS5ub3coKSB9O1xyXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vdXNlbW92ZShlKSB7XHJcbiAgICAgIGxldCB4ID0gKGUucGFnZVggLyB0aGlzLndpZHRoKSAqIDIgLSAxO1xyXG4gICAgICBsZXQgeSA9IChlLnBhZ2VZIC8gdGhpcy5oZWlnaHQpICogMiAtIDE7XHJcblxyXG4gICAgICB0aGlzLnVuaWZvcm1zLm1vdXNlbW92ZSA9IFt4LCB5XTtcclxuICAgIH1cclxuXHJcbiAgICByZXNpemUoZSkge1xyXG4gICAgICBjb25zdCBob2xkZXIgPSB0aGlzLmhvbGRlcjtcclxuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgIGNvbnN0IHdpZHRoID0gKHRoaXMud2lkdGggPSBob2xkZXIub2Zmc2V0V2lkdGgpO1xyXG4gICAgICBjb25zdCBoZWlnaHQgPSAodGhpcy5oZWlnaHQgPSBob2xkZXIub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgY29uc3QgYXNwZWN0ID0gKHRoaXMuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQpO1xyXG4gICAgICBjb25zdCBkcGkgPSBkZXZpY2VQaXhlbFJhdGlvO1xyXG5cclxuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcGk7XHJcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBkcGk7XHJcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xyXG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xyXG5cclxuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgd2lkdGggKiBkcGksIGhlaWdodCAqIGRwaSk7XHJcbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XHJcblxyXG4gICAgICB0aGlzLnVuaWZvcm1zLnJlc29sdXRpb24gPSBbd2lkdGgsIGhlaWdodF07XHJcbiAgICAgIHRoaXMudW5pZm9ybXMucHJvamVjdGlvbiA9IHRoaXMuc2V0UHJvamVjdGlvbihhc3BlY3QpO1xyXG5cclxuICAgICAgdGhpcy5vblJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBkcGkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFByb2plY3Rpb24oYXNwZWN0KSB7XHJcbiAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xyXG5cclxuICAgICAgaWYgKGNhbWVyYS5wZXJzcGVjdGl2ZSkge1xyXG4gICAgICAgIGNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XHJcblxyXG4gICAgICAgIGNvbnN0IGZvdlJhZCA9IGNhbWVyYS5mb3YgKiAoTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgICAgY29uc3QgZiA9IE1hdGgudGFuKE1hdGguUEkgKiAwLjUgLSAwLjUgKiBmb3ZSYWQpO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlSW52ID0gMS4wIC8gKGNhbWVyYS5uZWFyIC0gY2FtZXJhLmZhcik7XHJcblxyXG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IFtcclxuICAgICAgICAgIGYgLyBjYW1lcmEuYXNwZWN0LFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIGYsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgKGNhbWVyYS5uZWFyICsgY2FtZXJhLmZhcikgKiByYW5nZUludixcclxuICAgICAgICAgIC0xLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICBjYW1lcmEubmVhciAqIGNhbWVyYS5mYXIgKiByYW5nZUludiAqIDIsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIG1hdHJpeFsxNF0gKz0gY2FtZXJhLno7XHJcbiAgICAgICAgbWF0cml4WzE1XSArPSBjYW1lcmEuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgMiAvIHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgLTIgLyB0aGlzLmhlaWdodCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAxLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIC0xLFxyXG4gICAgICAgICAgMSxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAxLFxyXG4gICAgICAgIF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVTaGFkZXIodHlwZSwgc291cmNlKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG5cclxuICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcclxuICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG5cclxuICAgICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVByb2dyYW0odmVydGV4LCBmcmFnbWVudCkge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXgpO1xyXG4gICAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnQpO1xyXG5cclxuICAgICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcbiAgICAgIGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xyXG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XHJcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVVuaWZvcm1zKGRhdGEpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICBjb25zdCB1bmlmb3JtcyA9ICh0aGlzLmRhdGEudW5pZm9ybXMgPSBkYXRhKTtcclxuICAgICAgY29uc3QgdmFsdWVzID0gKHRoaXMudW5pZm9ybXMgPSB7fSk7XHJcblxyXG4gICAgICBPYmplY3Qua2V5cyh1bmlmb3JtcykuZm9yRWFjaCgobmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVuaWZvcm0gPSB1bmlmb3Jtc1tuYW1lXTtcclxuXHJcbiAgICAgICAgdW5pZm9ybS5sb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9cIiArIG5hbWUpO1xyXG5cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVzLCBuYW1lLCB7XHJcbiAgICAgICAgICBzZXQ6ICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB1bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnNldFVuaWZvcm0obmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGdldDogKCkgPT4gdW5pZm9ybXNbbmFtZV0udmFsdWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFVuaWZvcm0obmFtZSwgdmFsdWUpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICBjb25zdCB1bmlmb3JtID0gdGhpcy5kYXRhLnVuaWZvcm1zW25hbWVdO1xyXG5cclxuICAgICAgdW5pZm9ybS52YWx1ZSA9IHZhbHVlO1xyXG5cclxuICAgICAgc3dpdGNoICh1bmlmb3JtLnR5cGUpIHtcclxuICAgICAgICBjYXNlIFwiaW50XCI6IHtcclxuICAgICAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtLmxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcImZsb2F0XCI6IHtcclxuICAgICAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtLmxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcInZlYzJcIjoge1xyXG4gICAgICAgICAgZ2wudW5pZm9ybTJmKHVuaWZvcm0ubG9jYXRpb24sIC4uLnZhbHVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwidmVjM1wiOiB7XHJcbiAgICAgICAgICBnbC51bmlmb3JtM2YodW5pZm9ybS5sb2NhdGlvbiwgLi4udmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJ2ZWM0XCI6IHtcclxuICAgICAgICAgIGdsLnVuaWZvcm00Zih1bmlmb3JtLmxvY2F0aW9uLCAuLi52YWx1ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIm1hdDJcIjoge1xyXG4gICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdih1bmlmb3JtLmxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJtYXQzXCI6IHtcclxuICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodW5pZm9ybS5sb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwibWF0NFwiOiB7XHJcbiAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm0ubG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGl2ZWMyICAgICAgIDogdW5pZm9ybTJpLFxyXG4gICAgICAvLyBpdmVjMyAgICAgICA6IHVuaWZvcm0zaSxcclxuICAgICAgLy8gaXZlYzQgICAgICAgOiB1bmlmb3JtNGksXHJcbiAgICAgIC8vIHNhbXBsZXIyRCAgIDogdW5pZm9ybTFpLFxyXG4gICAgICAvLyBzYW1wbGVyQ3ViZSA6IHVuaWZvcm0xaSxcclxuICAgICAgLy8gYm9vbCAgICAgICAgOiB1bmlmb3JtMWksXHJcbiAgICAgIC8vIGJ2ZWMyICAgICAgIDogdW5pZm9ybTJpLFxyXG4gICAgICAvLyBidmVjMyAgICAgICA6IHVuaWZvcm0zaSxcclxuICAgICAgLy8gYnZlYzQgICAgICAgOiB1bmlmb3JtNGksXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlVW5pZm9ybXMoKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLmRhdGEudW5pZm9ybXM7XHJcblxyXG4gICAgICBPYmplY3Qua2V5cyh1bmlmb3JtcykuZm9yRWFjaCgobmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVuaWZvcm0gPSB1bmlmb3Jtc1tuYW1lXTtcclxuXHJcbiAgICAgICAgdGhpcy51bmlmb3Jtc1tuYW1lXSA9IHVuaWZvcm0udmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUJ1ZmZlcnMoZGF0YSkge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSAodGhpcy5kYXRhLmJ1ZmZlcnMgPSBkYXRhKTtcclxuICAgICAgY29uc3QgdmFsdWVzID0gKHRoaXMuYnVmZmVycyA9IHt9KTtcclxuXHJcbiAgICAgIE9iamVjdC5rZXlzKGJ1ZmZlcnMpLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW25hbWVdO1xyXG5cclxuICAgICAgICBidWZmZXIuYnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIoXCJhX1wiICsgbmFtZSwgYnVmZmVyLnNpemUpO1xyXG5cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVzLCBuYW1lLCB7XHJcbiAgICAgICAgICBzZXQ6IChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcnNbbmFtZV0uZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5hbWUsIGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJwb3NpdGlvblwiKVxyXG4gICAgICAgICAgICAgIHRoaXMuY291bnQgPSBidWZmZXJzLnBvc2l0aW9uLmRhdGEubGVuZ3RoIC8gMztcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBnZXQ6ICgpID0+IGJ1ZmZlcnNbbmFtZV0uZGF0YSxcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQnVmZmVyKG5hbWUsIHNpemUpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtO1xyXG5cclxuICAgICAgY29uc3QgaW5kZXggPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcclxuICAgICAgY29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4LCBzaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG5cclxuICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRCdWZmZXIobmFtZSwgZGF0YSkge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLmRhdGEuYnVmZmVycztcclxuXHJcbiAgICAgIGlmIChuYW1lID09IG51bGwgJiYgIWdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKSkgcmV0dXJuO1xyXG5cclxuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnNbbmFtZV0uYnVmZmVyKTtcclxuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoZGF0YSksIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVCdWZmZXJzKCkge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XHJcblxyXG4gICAgICBPYmplY3Qua2V5cyhidWZmZXJzKS5mb3JFYWNoKChuYW1lKSA9PiAoYnVmZmVyc1tuYW1lXSA9IGJ1ZmZlci5kYXRhKSk7XHJcblxyXG4gICAgICB0aGlzLnNldEJ1ZmZlcihudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVUZXh0dXJlKHNyYykge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuICAgICAgZ2wudGV4SW1hZ2UyRChcclxuICAgICAgICBnbC5URVhUVVJFXzJELFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgZ2wuUkdCQSxcclxuICAgICAgICAxLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgMCxcclxuICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsXHJcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDBdKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuXHJcbiAgICAgIGlmIChzcmMpIHtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLmhhc1RleHR1cmUgPSAxO1xyXG4gICAgICAgIHRoaXMubG9hZFRleHR1cmUoc3JjKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxvYWRUZXh0dXJlKHNyYykge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XHJcblxyXG4gICAgICBjb25zdCB0ZXh0dXJlSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICAgIHRleHR1cmVJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcblxyXG4gICAgICAgIGdsLnRleEltYWdlMkQoXHJcbiAgICAgICAgICBnbC5URVhUVVJFXzJELFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIGdsLlJHQkEsXHJcbiAgICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgICAgZ2wuVU5TSUdORURfQllURSxcclxuICAgICAgICAgIHRleHR1cmVJbWFnZVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xyXG5cclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRleHR1cmVJbWFnZS5zcmMgPSBzcmM7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgY29uc3QgZWxhcHNlZCA9IChub3cgLSB0aGlzLnRpbWUuc3RhcnQpIC8gNTAwMDtcclxuICAgICAgY29uc3QgZGVsdGEgPSBub3cgLSB0aGlzLnRpbWUub2xkO1xyXG4gICAgICB0aGlzLnRpbWUub2xkID0gbm93O1xyXG5cclxuICAgICAgdGhpcy51bmlmb3Jtcy50aW1lID0gZWxhcHNlZDtcclxuXHJcbiAgICAgIGlmICh0aGlzLmNvdW50ID4gMCkge1xyXG4gICAgICAgIC8vIGdsLmNsZWFyKGdsLkNPTE9SQlVGRkVSQklUKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgdGhpcy5jb3VudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMub25VcGRhdGUoZGVsdGEpO1xyXG5cclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHBvaW50U2l6ZSA9IDIuNTtcclxuXHJcbiAgY29uc3Qgd2F2ZXMgPSBuZXcgU2hhZGVyUHJvZ3JhbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLndhdmVzXCIpLCB7XHJcbiAgICB0ZXh0dXJlOlxyXG4gICAgICBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBTUFBQUJFcElyR0FBQUFiMUJNVkVVQUFBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vOHYwd0xSQUFBQUpIUlNUbE1BQy9nb0d2RGhtd2NFeHJWald6cm0yOVRScXFTS2VuUlhWa2xBTlNJVUU4bVJrR3B2K0hPZkFBQUJDRWxFUVZRNHk0VlQxM0xETUF3THJVSHRlTytSOWYvZldNZk82ZExhUGVLVkVFQ1J4T1VMV3NFR3BTOW5VTER3aWEyWStBTHFVTmJBV2VnNzc1enYrc0E0L0ZGUk14dDhVMkZaRkNWV2pSL1lySDQvSDlzYXJjbFNLZFBNV0t6YjhWc0VlSEIzbTBzaGtoVkN5TnplWGVBUTlYbDRvcEVpZVgyUUNHbndHYmo2R015anc5dDFLMGZLOVladW5QWGVBR3NmSnRZand6eGFCbm96R0dvcll6MHlwSzJIelFTWXgxeThEZ1NSbzJld09peWgyUVdPRWsxWTlPclFWMGE4VGlCTTFhOGVNSFdZblJNeTdDWjR0MUNteVJraFNVdlAzZ1JYeUhPQ0xCeE5vQzNJSnYvL1pySi9reHhVSFBVQis2akpaWkhycGc2R09qbnFhT216cDRORFI0OE9MeG4vSDI3U1JRMDhTMFpKQUFBQUFFbEZUa1N1UW1DQ1wiLFxyXG4gICAgdW5pZm9ybXM6IHtcclxuICAgICAgc2l6ZTogeyB0eXBlOiBcImZsb2F0XCIsIHZhbHVlOiBwb2ludFNpemUgfSxcclxuICAgICAgZmllbGQ6IHsgdHlwZTogXCJ2ZWMzXCIsIHZhbHVlOiBbMCwgMCwgMF0gfSxcclxuICAgICAgc3BlZWQ6IHsgdHlwZTogXCJmbG9hdFwiLCB2YWx1ZTogNSB9LFxyXG4gICAgfSxcclxuICAgIHZlcnRleDogYFxyXG4gICAgICAgICAgICAgICAjZGVmaW5lIE1fUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgYXR0cmlidXRlIHZlYzQgYV9wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X3RpbWU7XHJcbiAgICAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdV9zaXplO1xyXG4gICAgICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVfc3BlZWQ7XHJcbiAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1X2ZpZWxkO1xyXG4gICAgICAgICAgICAgICB1bmlmb3JtIG1hdDQgdV9wcm9qZWN0aW9uO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgIHZlYzMgcG9zID0gYV9wb3NpdGlvbi54eXo7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgcG9zLnkgKz0gKFxyXG4gICAgICAgICAgICAgICAgICAgY29zKHBvcy54IC8gdV9maWVsZC54ICogTV9QSSAqIDguMCArIHVfdGltZSAqIHVfc3BlZWQpICtcclxuICAgICAgICAgICAgICAgICAgIHNpbihwb3MueiAvIHVfZmllbGQueiAqIE1fUEkgKiA4LjAgKyB1X3RpbWUgKiB1X3NwZWVkKVxyXG4gICAgICAgICAgICAgICAgICkgKiB1X2ZpZWxkLnk7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiB2ZWM0KCBwb3MueHl6LCBhX3Bvc2l0aW9uLncgKTtcclxuICAgICAgICAgICAgICAgICBnbF9Qb2ludFNpemUgPSAoIHVfc2l6ZSAvIGdsX1Bvc2l0aW9uLncgKSAqIDEwMC4wO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgIHZfY29sb3IgPSBhX2NvbG9yO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB9YCxcclxuICAgIGZyYWdtZW50OiBgXHJcbiAgICAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3IgKiB0ZXh0dXJlMkQodV90ZXh0dXJlLCBnbF9Qb2ludENvb3JkKTtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgfWAsXHJcbiAgICBvblJlc2l6ZSh3LCBoLCBkcGkpIHtcclxuICAgICAgY29uc3QgcG9zaXRpb24gPSBbXSxcclxuICAgICAgICBjb2xvciA9IFtdO1xyXG5cclxuICAgICAgY29uc3Qgd2lkdGggPSA0MDAgKiAodyAvIGgpO1xyXG4gICAgICBjb25zdCBkZXB0aCA9IDQwMDtcclxuICAgICAgY29uc3QgaGVpZ2h0ID0gMztcclxuICAgICAgY29uc3QgZGlzdGFuY2UgPSA1O1xyXG5cclxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCArPSBkaXN0YW5jZSkge1xyXG4gICAgICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHogKz0gZGlzdGFuY2UpIHtcclxuICAgICAgICAgIHBvc2l0aW9uLnB1c2goLXdpZHRoIC8gMiArIHgsIC0zMCwgLWRlcHRoIC8gMiArIHopO1xyXG4gICAgICAgICAgY29sb3IucHVzaChcclxuICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgMSAtICh4IC8gd2lkdGgpICogMSxcclxuICAgICAgICAgICAgMC41ICsgKHggLyB3aWR0aCkgKiAwLjUsXHJcbiAgICAgICAgICAgIHogLyBkZXB0aFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudW5pZm9ybXMuZmllbGQgPSBbd2lkdGgsIGhlaWdodCwgZGVwdGhdO1xyXG5cclxuICAgICAgdGhpcy5idWZmZXJzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgIHRoaXMuYnVmZmVycy5jb2xvciA9IGNvbG9yO1xyXG5cclxuICAgICAgdGhpcy51bmlmb3Jtcy5zaXplID0gKGggLyA0MDApICogcG9pbnRTaXplICogZHBpO1xyXG4gICAgfSxcclxuICB9KTtcclxufTtcclxuIl0sIm5hbWVzIjpbIndhdmVzIiwiU2hhZGVyUHJvZ3JhbSIsImhvbGRlciIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJhbnRpYWxpYXMiLCJkZXB0aFRlc3QiLCJtb3VzZW1vdmUiLCJhdXRvc2l6ZSIsInNpZGUiLCJ2ZXJ0ZXgiLCJmcmFnbWVudCIsInVuaWZvcm1zIiwiYnVmZmVycyIsImNhbWVyYSIsInRleHR1cmUiLCJvblVwZGF0ZSIsIm9uUmVzaXplIiwidGltZSIsInR5cGUiLCJ2YWx1ZSIsImhhc1RleHR1cmUiLCJyZXNvbHV0aW9uIiwicHJvamVjdGlvbiIsInBvc2l0aW9uIiwic2l6ZSIsImRhdGEiLCJjb2xvciIsImZvdiIsIm5lYXIiLCJmYXIiLCJhc3BlY3QiLCJ6IiwicGVyc3BlY3RpdmUiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJnbCIsImdldENvbnRleHQiLCJjb3VudCIsImFwcGVuZENoaWxkIiwiY3JlYXRlUHJvZ3JhbSIsImNyZWF0ZUJ1ZmZlcnMiLCJjcmVhdGVVbmlmb3JtcyIsInVwZGF0ZUJ1ZmZlcnMiLCJ1cGRhdGVVbmlmb3JtcyIsImNyZWF0ZVRleHR1cmUiLCJlbmFibGUiLCJCTEVORCIsIkNVTExfRkFDRSIsImJsZW5kRnVuYyIsIlNSQ19BTFBIQSIsIk9ORSIsIkRFUFRIX1RFU1QiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInJlc2l6ZSIsInVwZGF0ZSIsImJpbmQiLCJzdGFydCIsInBlcmZvcm1hbmNlIiwibm93Iiwib2xkIiwieCIsInBhZ2VYIiwid2lkdGgiLCJ5IiwicGFnZVkiLCJoZWlnaHQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImRwaSIsImRldmljZVBpeGVsUmF0aW8iLCJzdHlsZSIsInZpZXdwb3J0IiwiY2xlYXJDb2xvciIsInNldFByb2plY3Rpb24iLCJmb3ZSYWQiLCJNYXRoIiwiUEkiLCJmIiwidGFuIiwicmFuZ2VJbnYiLCJtYXRyaXgiLCJjcmVhdGVTaGFkZXIiLCJzb3VyY2UiLCJzaGFkZXIiLCJzaGFkZXJTb3VyY2UiLCJjb21waWxlU2hhZGVyIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJjb25zb2xlIiwibG9nIiwiZ2V0U2hhZGVySW5mb0xvZyIsImRlbGV0ZVNoYWRlciIsInZlcnRleFNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJmcmFnbWVudFNoYWRlciIsIkZSQUdNRU5UX1NIQURFUiIsInByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsInVzZVByb2dyYW0iLCJnZXRQcm9ncmFtSW5mb0xvZyIsImRlbGV0ZVByb2dyYW0iLCJ2YWx1ZXMiLCJrZXlzIiwiZm9yRWFjaCIsIm5hbWUiLCJ1bmlmb3JtIiwibG9jYXRpb24iLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsInNldFVuaWZvcm0iLCJnZXQiLCJ1bmlmb3JtMWkiLCJ1bmlmb3JtMWYiLCJ1bmlmb3JtMmYiLCJ1bmlmb3JtM2YiLCJ1bmlmb3JtNGYiLCJ1bmlmb3JtTWF0cml4MmZ2IiwidW5pZm9ybU1hdHJpeDNmdiIsInVuaWZvcm1NYXRyaXg0ZnYiLCJidWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJzZXRCdWZmZXIiLCJsZW5ndGgiLCJpbmRleCIsImdldEF0dHJpYkxvY2F0aW9uIiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwiYnVmZmVyRGF0YSIsIkZsb2F0MzJBcnJheSIsIlNUQVRJQ19EUkFXIiwic3JjIiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwidGV4SW1hZ2UyRCIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwiVWludDhBcnJheSIsImxvYWRUZXh0dXJlIiwidGV4dHVyZUltYWdlIiwiSW1hZ2UiLCJvbmxvYWQiLCJ0ZXhQYXJhbWV0ZXJpIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiTElORUFSIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiVEVYVFVSRV9XUkFQX1MiLCJDTEFNUF9UT19FREdFIiwiVEVYVFVSRV9XUkFQX1QiLCJlbGFwc2VkIiwiZGVsdGEiLCJkcmF3QXJyYXlzIiwiUE9JTlRTIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicG9pbnRTaXplIiwicXVlcnlTZWxlY3RvciIsImZpZWxkIiwic3BlZWQiLCJ3IiwiaCIsImRlcHRoIiwiZGlzdGFuY2UiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/waves.js\n");

/***/ })

});